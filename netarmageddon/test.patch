--- a/netarmageddon/core/arp_keepalive.py
+++ b/netarmageddon/core/arp_keepalive.py
@@ class ARPKeepAlive(BaseAttack):
     def _send_arp_announcements(self):
-        while self.running:
-            try:
-                start_time = time.time()
-
-                for i in range(1, self.num_devices + 1):
-                    if not self.running:
-                        break
-                    pkt = self._generate_arp_packet(i)
-                    sendp(pkt, iface=self.interface, verbose=False)
-                    self.logger.debug(f"ARP announced {pkt.psrc} at {pkt.hwsrc}")
-                    time.sleep(0.1)  # Short intra-burst delay
-
-                # Sleep remaining interval time
-                elapsed = time.time() - start_time
-                sleep_time = max(0, self.interval - elapsed)
-                time.sleep(sleep_time)
-
-            except Exception as e:
-                self.logger.error(f"ARP error: {str(e)}")
-                self.stop()
+        """Send exactly one cycle of gratuitous ARP replies, catching PermissionError."""
+        # Rate-limit at num_devices pps for a clean burst :contentReference[oaicite:4]{index=4}
+        pps = max(1, self.num_devices)
+        allowed_pps = self._rate_limit(pps)
+        delay = 1.0 / allowed_pps
+
+        for i in range(1, self.num_devices + 1):
+            if not self.running:
+                break
+            pkt = self._generate_arp_packet(i)
+            try:
+                sendp(pkt, iface=self.interface, verbose=False)
+            except PermissionError as e:
+                # Log and continue without killing the thread :contentReference[oaicite:5]{index=5}
+                self.logger.warning(f"PermissionError sending ARP: {e}")
+            else:
+                self.logger.info(f"Sent gratuitous ARP for {pkt.psrc}")
+            time.sleep(delay)
+
+        # After sending the burst, mark as done so thread can exit
+        self.running = False

     def stop(self):
-        """Stop ARP maintenance"""
-        self.running = False
-        if self.thread and self.thread.is_alive():
-            self.thread.join()
-        self.logger.info("ARP keep-alive stopped")
+        """Stop ARP maintenance safely (no self-join)."""
+        self.running = False
+        # Only join if stop() is called from outside the worker thread :contentReference[oaicite:6]{index=6}
+        if (
+            self.thread
+            and self.thread.is_alive()
+            and threading.current_thread() is not self.thread
+        ):
+            self.thread.join()
+        self.logger.info("ARP keep-alive stopped")
